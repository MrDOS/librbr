/**
 * \file RBRInstrumentMemory.h
 *
 * \brief Instrument commands and structures pertaining to memory and data
 * retrieval.
 *
 * \see https://docs.rbr-global.com/L3commandreference/commands/memory-and-data-retrieval
 *
 * \copyright
 * Copyright (c) 2018 RBR Ltd.
 * Licensed under the Apache License, Version 2.0.
 */

#ifndef LIBRBR_RBRINSTRUMENTMEMORY_H
#define LIBRBR_RBRINSTRUMENTMEMORY_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * \brief The maximum number of channels which can be generated by a
 * post-processing job.
 */
#define RBRINSTRUMENT_POSTPROCESSING_CHANNEL_MAX 24

/**
 * \brief Possible instrument datasets.
 *
 * As an internal implementation detail, the instrument reuses file identifiers
 * (for standard and EasyParse data), and the identifiers are non-continuous
 * (there is no dataset 3). To keep confusion to a minimum, we use those same
 * identifiers here.
 */
typedef enum RBRInstrumentDataset
{
    /** EasyParse events */
    RBRINSTRUMENT_DATASET_EASYPARSE_EVENTS = 0,
    /** Standard data */
    RBRINSTRUMENT_DATASET_STANDARD = 1,
    /** EasyParse sample data */
    RBRINSTRUMENT_DATASET_EASYPARSE_SAMPLE_DATA = 1,
    /** EasyParse deployment header */
    RBRINSTRUMENT_DATASET_EASYPARSE_DEPLOYMENT_HEADER = 2,
    /** Reserved for use by the instrument. Cannot be downloaded. */
    RBRINSTRUMENT_DATASET_UNKNOWN_DATASET1 = 3,
    /** Post-processing sample data */
    RBRINSTRUMENT_DATASET_POSTPROCESSING_SAMPLE_DATA = 4,
    /** The number of specific datasets. */
    RBRINSTRUMENT_DATASET_COUNT,
    /** An unknown or unrecognized dataset. */
    RBRINSTRUMENT_UNKNOWN_DATASET
} RBRInstrumentDataset;

/**
 * \brief Get a human-readable string name for a dataset.
 *
 * Contrary to convention for values returned by other enum `_name` functions,
 * instances of “EasyParse” found in the names returned by this function are
 * capitalized: “EasyParse sample data” instead of “easyparse sample data”.
 * And, because the standard and EasyParse sample data datasets share an
 * identifier, “standard or EasyParse data” is returned for that value.
 *
 * \param [in] dataset the dataset
 * \return a string name for the dataset
 * \see RBRInstrumentError_name() for a description of the format of names
 */
const char *RBRInstrumentDataset_name(RBRInstrumentDataset dataset);

/**
 * \brief Instrument `meminfo` command parameters.
 *
 * \see RBRInstrument_getMemoryInfo()
 * \see https://docs.rbr-global.com/L3commandreference/commands/memory-and-data-retrieval/meminfo
 */
typedef struct RBRInstrumentMemoryInfo
{
    /** \brief The index of the dataset being queried. */
    RBRInstrumentDataset dataset;
    /** \brief The number of bytes being used to store data in the dataset. */
    int32_t used;
    /** \brief The number of bytes available for data storage. */
    int32_t remaining;
    /** \brief The maximum total size of the dataset in bytes. */
    int32_t size;
} RBRInstrumentMemoryInfo;

/**
 * \brief Get information about the usage and characteristics of data memory.
 *
 * RBRInstrumentMemoryInfo.dataset must be set to the index of the dataset for
 * which information is to be retrieved.
 *
 * ~~~{.c}
 * RBRInstrumentMemoryInfo memoryInfo;
 * memoryInfo.dataset = RBRINSTRUMENT_DATASET_STANDARD;
 * RBRInstrument_getMemoryInfo(instrument, &memoryInfo);
 * ~~~
 *
 * \param [in] instrument the instrument connection
 * \param [in,out] memoryInfo data memory information
 * \return #RBRINSTRUMENT_SUCCESS when the settings are successfully read
 * \return #RBRINSTRUMENT_TIMEOUT when a timeout occurs
 * \return #RBRINSTRUMENT_CALLBACK_ERROR returned by a callback
 * \return #RBRINSTRUMENT_INVALID_PARAMETER_VALUE when an invalid dataset is
 *                                                requested
 * \return #RBRINSTRUMENT_HARDWARE_ERROR if the dataset is unsupported
 * \see https://docs.rbr-global.com/L3commandreference/commands/memory-and-data-retrieval/meminfo
 */
RBRInstrumentError RBRInstrument_getMemoryInfo(
    RBRInstrument *instrument,
    RBRInstrumentMemoryInfo *memoryInfo);

/**
 * \brief Instrument `readdata` command parameters.
 *
 * \see RBRInstrument_readData()
 * \see https://docs.rbr-global.com/L3commandreference/commands/memory-and-data-retrieval/readdata
 */
typedef struct RBRInstrumentData
{
    /** \brief The index of the dataset being queried. */
    RBRInstrumentDataset dataset;
    /** \brief The amount of data read. */
    int32_t size;
    /** \brief The offset in memory of the data. */
    int32_t offset;
    /** \brief The data read from the instrument. */
    void *data;
} RBRInstrumentData;

/**
 * \brief Request a chunk of binary data from instrument data memory.
 *
 * When calling RBRInstrument_readData(), \a data must be populated:
 *
 * - RBRInstrumentData.dataset must be the index of the dataset to read from
 * - RBRInstrumentData.size must be the maximum amount of data to read
 * - RBRInstrumentData.offset must be the offset in memory from which to read
 * - RBRInstrumentData.data must be a pointer to a location to which the data
 *   can be written
 *
 * Upon return, \a data will have been modified so that the dataset, size, and
 * offset reflect the the instrument response. Be sure to check the reported
 * size as it may differ from the requested size, especially when the
 * instrument is busy or if you're reading the last chunk of the dataset.
 *
 * For example:
 *
 * ~~~{.c}
 * uint8_t buf[1400];
 * RBRInstrumentData data = {
 *     .dataset = RBRINSTRUMENT_DATASET_STANDARD,
 *     .size    = 1400,
 *     .offset  = 2800,
 *     .data    = buf
 * };
 * RBRInstrument_readData(instrument, &data);
 * fwrite(buf, data.size, 1, datasetFile);
 * ~~~
 *
 * A checksum error will be reported if the CRC check of the read data fails.
 * However, \a data will still faithfully reflect the response parameters and
 * data. Be sure to check the return value lest you accidentally consume
 * invalid/corrupt data!
 *
 * \param [in] instrument the instrument connection
 * \param [in,out] data the instrument data
 * \return #RBRINSTRUMENT_SUCCESS when the settings are successfully read
 * \return #RBRINSTRUMENT_TIMEOUT when a timeout occurs
 * \return #RBRINSTRUMENT_CALLBACK_ERROR returned by a callback
 * \return #RBRINSTRUMENT_CHECKSUM_ERROR in the event of a CRC failure
 * \return #RBRINSTRUMENT_INVALID_PARAMETER_VALUE when an invalid dataset is
 *                                                requested
 * \return #RBRINSTRUMENT_HARDWARE_ERROR if the dataset is unsupported
 * \see https://docs.rbr-global.com/L3commandreference/commands/memory-and-data-retrieval/readdata
 */
RBRInstrumentError RBRInstrument_readData(RBRInstrument *instrument,
                                          RBRInstrumentData *data);

/**
 * \brief Clear the data storage area of the flash memory.
 *
 * Currently, all datasets are erased, regardless of the data storage format in
 * use.
 *
 * \param [in] instrument the instrument connection
 * \return #RBRINSTRUMENT_SUCCESS when the settings are successfully read
 * \return #RBRINSTRUMENT_TIMEOUT when a timeout occurs
 * \return #RBRINSTRUMENT_CALLBACK_ERROR returned by a callback
 * \return #RBRINSTRUMENT_HARDWARE_ERROR if the memory failed to erase
 * \see https://docs.rbr-global.com/L3commandreference/commands/memory-and-data-retrieval/memclear
 */
RBRInstrumentError RBRInstrument_memoryClear(RBRInstrument *instrument);

/**
 * \brief Instrument memory formats.
 *
 * \see RBRInstrument_getAvailableMemoryFormats()
 * \see RBRInstrument_getCurrentMemoryFormat()
 * \see RBRInstrument_getNewMemoryFormat()
 * \see RBRInstrument_setNewMemoryFormat()
 * \see https://docs.rbr-global.com/L3commandreference/commands/memory-and-data-retrieval/memformat
 */
typedef enum RBRInstrumentMemoryFormat
{
    /** No format. */
    RBRINSTRUMENT_MEMFORMAT_NONE     =      0,
    /** “Standard” format, `rawbin00`. */
    RBRINSTRUMENT_MEMFORMAT_RAWBIN00 = 1 << 0,
    /** “EasyParse” format, `calbin00`. */
    RBRINSTRUMENT_MEMFORMAT_CALBIN00 = 1 << 1,
    /** Corresponds to the largest memory format enum value. */
    RBRINSTRUMENT_MEMFORMAT_MAX      = RBRINSTRUMENT_MEMFORMAT_CALBIN00
} RBRInstrumentMemoryFormat;

/**
 * \brief Get a human-readable string name for a memory format.
 *
 * \param [in] format the memory format
 * \return a string name for the memory format
 * \see RBRInstrumentError_name() for a description of the format of names
 */
const char *RBRInstrumentMemoryFormat_name(RBRInstrumentMemoryFormat format);

/**
 * \brief Report a list of available memory formats.
 *
 * \a memoryFormats will be treated as a bit field representation of available
 * memory formats as defined by RBRInstrumentMemoryFormat. For details, consult
 * [Working with Bit Fields](bitfields.md).
 *
 * \param [in] instrument the instrument connection
 * \param [out] memoryFormats available memory formats
 * \return #RBRINSTRUMENT_SUCCESS when the settings are successfully read
 * \return #RBRINSTRUMENT_TIMEOUT when a timeout occurs
 * \return #RBRINSTRUMENT_CALLBACK_ERROR returned by a callback
 * \see https://docs.rbr-global.com/L3commandreference/commands/memory-and-data-retrieval/memformat
 */
RBRInstrumentError RBRInstrument_getAvailableMemoryFormats(
    RBRInstrument *instrument,
    RBRInstrumentMemoryFormat *memoryFormats);

/**
 * \brief Get the current memory format.
 *
 * Retrieves the format of the data presently stored in memory, either for a
 * deployment in progress or for one which has finished. If the memory is
 * completely empty because it has been cleared, the response will be
 * #RBRINSTRUMENT_MEMFORMAT_NONE.
 *
 * \param [in] instrument the instrument connection
 * \param [out] memoryFormat the current memory format
 * \return #RBRINSTRUMENT_SUCCESS when the settings are successfully read
 * \return #RBRINSTRUMENT_TIMEOUT when a timeout occurs
 * \return #RBRINSTRUMENT_CALLBACK_ERROR returned by a callback
 * \see https://docs.rbr-global.com/L3commandreference/commands/memory-and-data-retrieval/memformat
 */
RBRInstrumentError RBRInstrument_getCurrentMemoryFormat(
    RBRInstrument *instrument,
    RBRInstrumentMemoryFormat *memoryFormat);

/**
 * \brief Get the memory format to be used for the next deployment.
 *
 * \param [in] instrument the instrument connection
 * \param [out] memoryFormat the new memory format
 * \return #RBRINSTRUMENT_SUCCESS when the settings are successfully read
 * \return #RBRINSTRUMENT_TIMEOUT when a timeout occurs
 * \return #RBRINSTRUMENT_CALLBACK_ERROR returned by a callback
 * \see https://docs.rbr-global.com/L3commandreference/commands/memory-and-data-retrieval/memformat
 */
RBRInstrumentError RBRInstrument_getNewMemoryFormat(
    RBRInstrument *instrument,
    RBRInstrumentMemoryFormat *memoryFormat);

/**
 * \brief Set the memory format to be used for the next deployment.
 *
 * Hardware errors may occur if:
 *
 * - the instrument is logging
 * - you select an unavailable memory format
 *
 * \param [in] instrument the instrument connection
 * \param [in] memoryFormat the new memory format
 * \return #RBRINSTRUMENT_SUCCESS when the settings are successfully read
 * \return #RBRINSTRUMENT_TIMEOUT when a timeout occurs
 * \return #RBRINSTRUMENT_CALLBACK_ERROR returned by a callback
 * \return #RBRINSTRUMENT_INVALID_PARAMETER_VALUE when an invalid format is
 *                                                requested
 * \return #RBRINSTRUMENT_HARDWARE_ERROR when the instrument is logging or if
 *                                       an unavailable memory format is
 *                                       selected
 * \see https://docs.rbr-global.com/L3commandreference/commands/memory-and-data-retrieval/memformat
 */
RBRInstrumentError RBRInstrument_setNewMemoryFormat(
    RBRInstrument *instrument,
    RBRInstrumentMemoryFormat memoryFormat);

/**
 * \brief Functions available to aggregate channel values within bins.
 *
 * \see RBRInstrumentPostprocessingChannel
 * \see https://docs.rbr-global.com/L3commandreference/commands/memory-and-data-retrieval/postprocessing
 */
typedef enum RBRInstrumentPostprocessingAggregate
{
    /** average value in the bin */
    RBRINSTRUMENT_POSTPROCESSING_AGGREGATE_MEAN,
    /** standard deviation of the bin */
    RBRINSTRUMENT_POSTPROCESSING_AGGREGATE_STD,
    /** number of samples in the bin */
    RBRINSTRUMENT_POSTPROCESSING_AGGREGATE_SAMPLE_COUNT,
    /** The number of specific post-processing aggregate functions. */
    RBRINSTRUMENT_POSTPROCESSING_AGGREGATE_COUNT,
    /** An unknown or unrecognized post-processing aggregate function. */
    RBRINSTRUMENT_UNKNOWN_POSTPROCESSING_AGGREGATE
} RBRInstrumentPostprocessingAggregate;

/**
 * \brief Get a human-readable string name for an aggregate function.
 *
 * For consistency with the instrument command language, returns “count”, not
 * “sample count”, for #RBRINSTRUMENT_POSTPROCESSING_AGGREGATE_SAMPLE_COUNT.
 * The value name only includes `_SAMPLE` to disambiguate between the aggregate
 * function and the value which is the count of valid values,
 * #RBRINSTRUMENT_POSTPROCESSING_AGGREGATE_COUNT.
 *
 * \param [in] function the aggregate function
 * \return a string name for the aggregate function
 * \see RBRInstrumentError_name() for a description of the format of names
 */
const char *RBRInstrumentPostprocessingAggregate_name(
    RBRInstrumentPostprocessingAggregate function);

/**
 * Post-processing channel configurations.
 *
 * \see RBRInstrumentPostprocessing
 * \see https://docs.rbr-global.com/L3commandreference/commands/memory-and-data-retrieval/postprocessing
 */
typedef struct RBRInstrumentPostprocessingChannelsList
{
    /** \brief The number of channels generated by post-processing. */
    int32_t count;
    /** \brief The definitions of post-processing channels. */
    struct
    {
        /** \brief The function used to aggregate values within bins. */
        RBRInstrumentPostprocessingAggregate function;
        /** \brief The label of the channel to aggregate. */
        char label[RBRINSTRUMENT_CHANNEL_LABEL_MAX + 1];
    } channels[RBRINSTRUMENT_POSTPROCESSING_CHANNEL_MAX];
} RBRInstrumentPostprocessingChannelsList;

/**
 * \brief Post-processing job statuses.
 *
 * \see RBRInstrumentPostprocessing
 * \see https://docs.rbr-global.com/L3commandreference/commands/memory-and-data-retrieval/postprocessing
 */
typedef enum RBRInstrumentPostprocessingStatus
{
    /** Post-processing is idle. */
    RBRINSTRUMENT_POSTPROCESSING_STATUS_IDLE,
    /** Post-processing is in progress. */
    RBRINSTRUMENT_POSTPROCESSING_STATUS_PROCESSING,
    /** Post-processing has completed. */
    RBRINSTRUMENT_POSTPROCESSING_STATUS_COMPLETED,
    /** Post-processing has been aborted. */
    RBRINSTRUMENT_POSTPROCESSING_STATUS_ABORTED,
    /** The number of specific post-processing statuses. */
    RBRINSTRUMENT_POSTPROCESSING_STATUS_COUNT,
    /** An unknown or unrecognized post-processing status. */
    RBRINSTRUMENT_UNKNOWN_POSTPROCESSING_STATUS
} RBRInstrumentPostprocessingStatus;

/**
 * \brief Get a human-readable string name for a post-processing status.
 *
 * \param [in] status the post-processing status
 * \return a string name for the post-processing status
 * \see RBRInstrumentError_name() for a description of the format of names
 */
const char *RBRInstrumentPostprocessingStatus_name(
    RBRInstrumentPostprocessingStatus status);

/**
 * \brief Post-processing control commands.
 *
 * \see RBRInstrumentPostprocessing
 * \see https://docs.rbr-global.com/L3commandreference/commands/memory-and-data-retrieval/postprocessing
 */
typedef enum RBRInstrumentPostprocessingCommand
{
    /** Start the post-processing job. */
    RBRINSTRUMENT_POSTPROCESSING_COMMAND_START,
    /** Reset the post-processing job. */
    RBRINSTRUMENT_POSTPROCESSING_COMMAND_RESET,
    /** Abort any current post-processing job. */
    RBRINSTRUMENT_POSTPROCESSING_COMMAND_ABORT,
    /** The number of specific post-processing commands. */
    RBRINSTRUMENT_POSTPROCESSING_COMMAND_COUNT,
    /** An unknown or unrecognized post-processing command. */
    RBRINSTRUMENT_UNKNOWN_POSTPROCESSING_COMMAND
} RBRInstrumentPostprocessingCommand;

/**
 * \brief Get a human-readable string name for a post-processing command.
 *
 * \param [in] command the post-processing command
 * \return a string name for the post-processing command
 * \see RBRInstrumentError_name() for a description of the format of names
 */
const char *RBRInstrumentPostprocessingCommand_name(
    RBRInstrumentPostprocessingCommand command);

/**
 * \brief Post-processing bin filters.
 *
 * \see RBRInstrumentPostprocessing
 * \see https://docs.rbr-global.com/L3commandreference/commands/memory-and-data-retrieval/postprocessing
 */
typedef enum RBRInstrumentPostprocessingBinFilter
{
    /** No filter. */
    RBRINSTRUMENT_POSTPROCESSING_BINFILTER_NONE,
    /**
     * \brief Only ascending values.
     *
     * Equivalent to ascending regimes binning. Only valid when binning by
     * depth.
     */
    RBRINSTRUMENT_POSTPROCESSING_BINFILTER_ASCENTONLY,
    /**
     * \brief Only descending values.
     *
     * Equivalent to descending regimes binning. Only valid when binning by
     * depth.
     */
    RBRINSTRUMENT_POSTPROCESSING_BINFILTER_DESCENTONLY,
    /** The number of specific post-processing bin filters. */
    RBRINSTRUMENT_POSTPROCESSING_BINFILTER_COUNT,
    /** An unknown or unrecognized post-processing bin filter. */
    RBRINSTRUMENT_UNKNOWN_POSTPROCESSING_BINFILTER
} RBRInstrumentPostprocessingBinFilter;

/**
 * \brief Get a human-readable string name for a post-processing bin filter.
 *
 * \param [in] filter the post-processing bin filter
 * \return a string name for the post-processing bin filter
 * \see RBRInstrumentError_name() for a description of the format of names
 */
const char *RBRInstrumentPostprocessingBinFilter_name(
    RBRInstrumentPostprocessingBinFilter filter);

/**
 * \brief The instrument post-processing configuration.
 *
 * \see RBRInstrument_getPostprocessing()
 * \see RBRInstrument_setPostprocessing()
 * \see https://docs.rbr-global.com/L3commandreference/commands/memory-and-data-retrieval/postprocessing
 */
typedef struct RBRInstrumentPostprocessing
{
    /**
     * \brief The current state of the instrument's post-processing function.
     *
     * \readonly
     */
    RBRInstrumentPostprocessingStatus status;
    /**
     * \brief Post-processing statistics channel configurations.
     *
     * Functions which receive an RBRInstrumentPostprocessing instance will
     * expect the first RBRInstrumentPostprocessingChannelList.count entries to
     * be populated, and functions which return a RBRInstrumentPostprocessing
     * instance will similarly indicate how many entries are populated.
     */
    RBRInstrumentPostprocessingChannelsList channels;
    /**
     * \brief The reference channel for binning.
     *
     * If the reference is set to the keyword `tstamp`, the generated data will
     * be binned by time. Otherwise, if the reference is set to the channel
     * label of a pressure or sea pressure channel, the generated data is
     * binned by depth.
     */
    char binReference[RBRINSTRUMENT_CHANNEL_LABEL_MAX + 1];
    /** \brief How data should be filtered before binning. */
    RBRInstrumentPostprocessingBinFilter binFilter;
    /**
     * \brief The size of each bin.
     *
     * When binning by time: specified in milliseconds, with a precision of
     * milliseconds.
     *
     * When binning by depth: specified in decibars, with a minimum precision
     * of 0.1 dbar.
     *
     * The bin size can always be set to 0, in which case, no binning is
     * performed.
     *
     * The bin size may never be negative.
     */
    float binSize;
    /**
     * \brief The minimum timestamp value.
     *
     * All samples with an earlier timestamp are excluded from post-processing
     * input. If time binning is used, this serves as the binning origin point.
     */
    RBRInstrumentDateTime tstampMin;
    /**
     * \brief The maximum timestamp value.
     *
     * All samples with a later timestamp are excluded from post-processing
     * input.
     */
    RBRInstrumentDateTime tstampMax;
    /**
     * \brief The minimum depth value.
     *
     * Specified in decibar with a minimum precision of 0.1 dbar.
     *
     * This parameter is ignored when binning by time.
     *
     * When binning by depth, all samples with a lesser depth are excluded from
     * post-processing input; and unless the bin filter is set to
     * #RBRINSTRUMENT_POSTPROCESSING_BINFILTER_ASCENTONLY, this serves as the
     * binning origin point.
     */
    float depthMin;
    /**
     * \brief The maximum depth value.
     *
     * Specified in decibar with a minimum precision of 0.1 dbar.
     *
     * This parameter is ignored when binning by time.
     *
     * When binning by depth, all samples with a greater depth are excluded
     * from post-processing input; and if the bin filter is set to
     * #RBRINSTRUMENT_POSTPROCESSING_BINFILTER_DESCENTONLY, this serves as the
     * binning origin point.
     */
    float depthMax;
} RBRInstrumentPostprocessing;

/**
 * \brief Get the instrument post-processing settings.
 *
 * \param [in] instrument the instrument connection
 * \param [out] postprocessing the post-processing parameters
 * \return #RBRINSTRUMENT_SUCCESS when the settings are successfully read
 * \return #RBRINSTRUMENT_TIMEOUT when a timeout occurs
 * \return #RBRINSTRUMENT_CALLBACK_ERROR returned by a callback
 * \return #RBRINSTRUMENT_HARDWARE_ERROR when the feature is unavailable
 * \see https://docs.rbr-global.com/L3commandreference/commands/memory-and-data-retrieval/postprocessing
 */
RBRInstrumentError RBRInstrument_getPostprocessing(
    RBRInstrument *instrument,
    RBRInstrumentPostprocessing *postprocessing);

/**
 * \brief Set the instrument post-processing settings.
 *
 * Hardware errors may occur if:
 *
 * - post-processing is not available for the instrument
 * - a post-processing job is already running
 * - you set an out-of-bounds parameter the library fails to detect
 *
 * \param [in] instrument the instrument connection
 * \param [in] postprocessing the post-processing parameters
 * \return #RBRINSTRUMENT_SUCCESS when the settings are successfully written
 * \return #RBRINSTRUMENT_TIMEOUT when a timeout occurs
 * \return #RBRINSTRUMENT_CALLBACK_ERROR returned by a callback
 * \return #RBRINSTRUMENT_HARDWARE_ERROR when the settings cannot be changed
 * \return #RBRINSTRUMENT_INVALID_PARAMETER_VALUE when parameter values are out
 *                                                of range
 * \see https://docs.rbr-global.com/L3commandreference/commands/memory-and-data-retrieval/postprocessing
 */
RBRInstrumentError RBRInstrument_setPostprocessing(
    RBRInstrument *instrument,
    const RBRInstrumentPostprocessing *postprocessing);

/**
 * \brief Exercises control over the post-processing state.
 *
 * Hardware errors may occur if:
 *
 * - post-processing is not available for the instrument
 * - post-processing settings are invalid
 * - the wrong memory format is in use
 * - the requested reference channel is unavailable
 *
 * \param [in] instrument the instrument connection
 * \param [in] command the post-processing command
 * \param [out] status the post-processing status after executing the command
 * \return #RBRINSTRUMENT_SUCCESS when the settings are successfully written
 * \return #RBRINSTRUMENT_TIMEOUT when a timeout occurs
 * \return #RBRINSTRUMENT_CALLBACK_ERROR returned by a callback
 * \return #RBRINSTRUMENT_HARDWARE_ERROR when the settings cannot be changed
 * \return #RBRINSTRUMENT_INVALID_PARAMETER_VALUE when parameter values are out
 *                                                of range
 * \see https://docs.rbr-global.com/L3commandreference/commands/memory-and-data-retrieval/postprocessing
 */
RBRInstrumentError RBRInstrument_setPostprocessingCommand(
    RBRInstrument *instrument,
    RBRInstrumentPostprocessingCommand command,
    RBRInstrumentPostprocessingStatus *status);

#ifdef __cplusplus
}
#endif

#endif /* LIBRBR_RBRINSTRUMENTMEMORY_H */
